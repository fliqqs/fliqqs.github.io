<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  babyarx Â· fliqqs
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Fliqqs">
<meta name="description" content="For this challenge we are given a .py file and the resulting hash.
class baby_arx():  def __init__(self, key):  assert len(key) == 64  self.state = list(key)   def b(self):  b1 = self.state[0]  b2 = self.state[1]  b1 = (b1 ^ ((b1 &lt;&lt; 1) | (b1 &amp; 1))) &amp; 0xff  b2 = (b2 ^ ((b2 &gt;&gt; 5) | (b2 &lt;&lt; 3))) &amp; 0xff  b = (b1 &#43; b2) % 256  self.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="babyarx"/>
<meta name="twitter:description" content="For this challenge we are given a .py file and the resulting hash.
class baby_arx():  def __init__(self, key):  assert len(key) == 64  self.state = list(key)   def b(self):  b1 = self.state[0]  b2 = self.state[1]  b1 = (b1 ^ ((b1 &lt;&lt; 1) | (b1 &amp; 1))) &amp; 0xff  b2 = (b2 ^ ((b2 &gt;&gt; 5) | (b2 &lt;&lt; 3))) &amp; 0xff  b = (b1 &#43; b2) % 256  self."/>

<meta property="og:title" content="babyarx" />
<meta property="og:description" content="For this challenge we are given a .py file and the resulting hash.
class baby_arx():  def __init__(self, key):  assert len(key) == 64  self.state = list(key)   def b(self):  b1 = self.state[0]  b2 = self.state[1]  b1 = (b1 ^ ((b1 &lt;&lt; 1) | (b1 &amp; 1))) &amp; 0xff  b2 = (b2 ^ ((b2 &gt;&gt; 5) | (b2 &lt;&lt; 3))) &amp; 0xff  b = (b1 &#43; b2) % 256  self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.example.com/posts/babyarx/babyarx/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-25T16:56:10+10:00" />
<meta property="article:modified_time" content="2022-10-25T16:56:10+10:00" />





<link rel="canonical" href="http://www.example.com/posts/babyarx/babyarx/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.65236a6d834b26194eed04a2a3b45e44d9194ef9e620253705d4bef03bd7ef81.css" integrity="sha256-ZSNqbYNLJhlO7QSio7ReRNkZTvnmICU3BdS&#43;8DvX74E=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.f6534b0b446b75d9b6ad77a97d43ede2ddaeff1b6e2361fb7198d6f8fcb7f83f.css" integrity="sha256-9lNLC0Rrddm2rXepfUPt4t2u/xtuI2H7cZjW&#43;Py3&#43;D8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      fliqqs
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blog</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.example.com/posts/babyarx/babyarx/">
              babyarx
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-10-25T16:56:10&#43;10:00">
                October 25, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              3-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ductf2022/">ductf2022</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <p>For this challenge we are given a .py file and the resulting hash.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> baby_arx():
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">assert</span> <span style="color:#fff;font-weight:bold">len</span>(key) == <span style="color:#ff0;font-weight:bold">64</span>
</span></span><span style="display:flex;"><span>        self.state = <span style="color:#fff;font-weight:bold">list</span>(key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">def</span> b(self):
</span></span><span style="display:flex;"><span>        b1 = self.state[<span style="color:#ff0;font-weight:bold">0</span>]
</span></span><span style="display:flex;"><span>        b2 = self.state[<span style="color:#ff0;font-weight:bold">1</span>]
</span></span><span style="display:flex;"><span>        b1 = (b1 ^ ((b1 &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>) | (b1 &amp; <span style="color:#ff0;font-weight:bold">1</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>        b2 = (b2 ^ ((b2 &gt;&gt; <span style="color:#ff0;font-weight:bold">5</span>) | (b2 &lt;&lt; <span style="color:#ff0;font-weight:bold">3</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>        b = (b1 + b2) % <span style="color:#ff0;font-weight:bold">256</span>
</span></span><span style="display:flex;"><span>        self.state = self.state[<span style="color:#ff0;font-weight:bold">1</span>:] + [b]
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">def</span> stream(self, n):
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">bytes</span>([self.b() <span style="color:#fff;font-weight:bold">for</span> _ in <span style="color:#fff;font-weight:bold">range</span>(n)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FLAG = <span style="color:#fff;font-weight:bold">open</span>(<span style="color:#0ff;font-weight:bold">&#39;./flag.txt&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;rb&#39;</span>).read().strip()
</span></span><span style="display:flex;"><span>cipher = baby_arx(FLAG)
</span></span><span style="display:flex;"><span>out = cipher.stream(<span style="color:#ff0;font-weight:bold">64</span>).hex()
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">print</span>(out)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># cb57ba706aae5f275d6d8941b7c7706fe261b7c74d3384390b691c3d982941ac4931c6a4394a1a7b7a336bc3662fd0edab3ff8b31b96d112a026f93fff07e61b</span>
</span></span></code></pre></div><p>Just from the source code we can see that the flag length is 64. The cipher takes the current bytes and performs and, rotate, xor. Then adds this with the next byte to get the cipher text.</p>
<p>The cipher uses the next letter and the current to generate the cipher text. This means if we know the current letter and the cipher text we can brute force what the next character is.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> solve_next_letter(current_character, current_ct):
</span></span><span style="display:flex;"><span>    byte_one = b1_hashes[current_character]
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">#brute force other hash</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> c in string.printable:
</span></span><span style="display:flex;"><span>        byte_two = b2_hashes[c]
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (byte_one + byte_two) % <span style="color:#ff0;font-weight:bold">256</span> == current_ct:
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> c
</span></span></code></pre></div><p>Code is needed to then keep track of ingesting the hash and turning it into byte sections.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>CT = <span style="color:#0ff;font-weight:bold">&#34;cb57ba706aae5f275d6d8941b7c7706fe261b7c74d3384390b691c3d982941ac4931c6a4394a1a7b7a336bc3662fd0edab3ff8b31b96d112a026f93fff07e61b&#34;</span>
</span></span><span style="display:flex;"><span>CT_BYTES=[]
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> x in <span style="color:#fff;font-weight:bold">range</span>(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#fff;font-weight:bold">len</span>(CT),<span style="color:#ff0;font-weight:bold">2</span>):
</span></span><span style="display:flex;"><span>    CT_BYTES.append(CT[x:x+<span style="color:#ff0;font-weight:bold">2</span>])
</span></span></code></pre></div><p>We then create a hash map of all the possible hashes given the two ARX operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#007f7f">#calculate all hashes</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> c in string.printable:
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">print</span>(c)
</span></span><span style="display:flex;"><span>    char_code = <span style="color:#fff;font-weight:bold">ord</span>(c)
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#39;char code </span><span style="color:#0ff;font-weight:bold">{</span>char_code<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> c: </span><span style="color:#0ff;font-weight:bold">{</span>c<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#39;</span>)
</span></span><span style="display:flex;"><span>    b1_hashes[c] = (char_code ^ ((char_code &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>) | (char_code &amp; <span style="color:#ff0;font-weight:bold">1</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>    b2_hashes[c] = (char_code ^ ((char_code &gt;&gt; <span style="color:#ff0;font-weight:bold">5</span>) | (char_code &lt;&lt; <span style="color:#ff0;font-weight:bold">3</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span></code></pre></div><p>We know that a flag starts with &ldquo;DUCTF{ so we can use that to kick off solving the cipher text. Putting it all together results in the following code.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#007f7f">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> string
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CT = <span style="color:#0ff;font-weight:bold">&#34;cb57ba706aae5f275d6d8941b7c7706fe261b7c74d3384390b691c3d982941ac4931c6a4394a1a7b7a336bc3662fd0edab3ff8b31b96d112a026f93fff07e61b&#34;</span>
</span></span><span style="display:flex;"><span>CT_BYTES=[]
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> x in <span style="color:#fff;font-weight:bold">range</span>(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#fff;font-weight:bold">len</span>(CT),<span style="color:#ff0;font-weight:bold">2</span>):
</span></span><span style="display:flex;"><span>    CT_BYTES.append(CT[x:x+<span style="color:#ff0;font-weight:bold">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>b1_hashes = {}
</span></span><span style="display:flex;"><span>b2_hashes = {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">#calculate all hashes</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> c in string.printable:
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">print</span>(c)
</span></span><span style="display:flex;"><span>    char_code = <span style="color:#fff;font-weight:bold">ord</span>(c)
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#39;char code </span><span style="color:#0ff;font-weight:bold">{</span>char_code<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold"> c: </span><span style="color:#0ff;font-weight:bold">{</span>c<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#39;</span>)
</span></span><span style="display:flex;"><span>    b1_hashes[c] = (char_code ^ ((char_code &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>) | (char_code &amp; <span style="color:#ff0;font-weight:bold">1</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>    b2_hashes[c] = (char_code ^ ((char_code &gt;&gt; <span style="color:#ff0;font-weight:bold">5</span>) | (char_code &lt;&lt; <span style="color:#ff0;font-weight:bold">3</span>))) &amp; <span style="color:#ff0;font-weight:bold">0xff</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag=<span style="color:#0ff;font-weight:bold">&#34;DUCTF{&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">#cut the first 5 bytes</span>
</span></span><span style="display:flex;"><span>CT_BYTES = CT_BYTES[<span style="color:#ff0;font-weight:bold">5</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> solve_next_letter(current_character, current_ct):
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">print</span>(<span style="color:#0ff;font-weight:bold">f</span><span style="color:#0ff;font-weight:bold">&#34;looking up </span><span style="color:#0ff;font-weight:bold">{</span>current_character<span style="color:#0ff;font-weight:bold">}</span><span style="color:#0ff;font-weight:bold">&#34;</span>)
</span></span><span style="display:flex;"><span>    byte_one = b1_hashes[current_character]
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">#brute force other hash</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> c in string.printable:
</span></span><span style="display:flex;"><span>        byte_two = b2_hashes[c]
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (byte_one + byte_two) % <span style="color:#ff0;font-weight:bold">256</span> == current_ct:
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">while</span> <span style="color:#fff;font-weight:bold">len</span>(CT_BYTES):
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">#we know what the current CT and PT</span>
</span></span><span style="display:flex;"><span>    current_letter = flag[-<span style="color:#ff0;font-weight:bold">1</span>:]
</span></span><span style="display:flex;"><span>    current_ct = <span style="color:#fff;font-weight:bold">int</span>(CT_BYTES[<span style="color:#ff0;font-weight:bold">0</span>],<span style="color:#ff0;font-weight:bold">16</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    next_letter = solve_next_letter(current_letter,current_ct)
</span></span><span style="display:flex;"><span>    flag += <span style="color:#fff;font-weight:bold">str</span>(next_letter)
</span></span><span style="display:flex;"><span>    CT_BYTES.pop(<span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">print</span>(flag)
</span></span></code></pre></div>
      </div>


      <footer>
        


        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2023
     Fliqqs 
    Â·
    
    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>